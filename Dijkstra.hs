module Dijkstra 
    ( dijkstra
    , pruning
    ) where

import qualified Data.Map.Strict as M
import qualified Data.Set as S
import Data.List (foldl', lookup)

type CostMap cost state = (M.Map state cost, S.Set (cost, state))

nearest ::
    (Ord state, Ord cost)
    => CostMap cost state
    -> Maybe state
nearest (_, s) = if S.null s
    then Nothing
    else Just $ snd $ S.findMin s

insert ::
    (Ord state, Ord cost)
    => state
    -> cost
    -> CostMap cost state
    -> CostMap cost state
insert p d (m, s) =
    let m' = M.insert p d m
    in if M.notMember p m
        then (m', S.insert (d, p) s)
        else (m', S.insert (d, p) $ S.delete (m M.! p, p) s)

delete ::
    (Ord state, Ord cost)
    => state
    -> CostMap cost state
    -> CostMap cost state
delete p (m, s) =
    if M.notMember p m
        then (m, s)
        else (M.delete p m, S.delete (m M.! p, p) s)

singleton ::
    (Ord state, Num cost)
    => state
    -> CostMap cost state
singleton p = (M.singleton p 0, S.singleton (0, p))

addCost ::
    (Ord state, Ord cost, Num cost)
    => state
    -> (CostMap cost state, M.Map state state)
    -> (state, cost)
    -> (CostMap cost state, M.Map state state)
addCost current ((m, s), previous) (p, d) =
    let previous' = M.insert p current previous
        d' = m M.! current + d
    in if M.notMember p m
        then (insert p d' (m, s), previous')
        else let d'' = m M.! p
             in if d'' < d'
                 then ((m, s), previous)
                 else (insert p d' (m, s), previous')

path ::
    (Ord state)
    => M.Map state state
    -> state
    -> [state]
path previous current
    | M.notMember current previous = [current]
    | otherwise = current : (path previous $ previous M.! current)

-- | @next \`pruning\` predicate@ removes states which satisfy @predicate@
-- from the list generated by @next@. This is useful for the common case when
-- you want to logically separate your search's `next` function from some way
-- of determining when you've reached a dead end.
pruning ::
    (state -> [(state, cost)]) 
    -> (state -> Bool) 
    -> (state -> [(state, cost)])
next `pruning` predicate =
    (filter (not . predicate . fst) ) <$> next

dijkstra' ::
    (Ord state, Ord cost, Num cost)
    => (state -> [(state, cost)])
    -> (state -> Bool)
    -> S.Set state
    -> M.Map state state
    -> CostMap cost state
    -> state
    -> Maybe (cost, [state])
dijkstra' next found visited previous costs current =
    let unvisitedNeighbors = (next `pruning` (\x -> S.member x visited)) current
    in let (costs', previous') = foldl' (addCost current)
                                     (costs, previous) unvisitedNeighbors
           visited' = S.insert current visited
           costs'' = delete current costs'
       in if found current
           then Just ( fst costs' M.! current
                     , reverse $ path previous current)
           else do
               current' <- nearest costs''
               dijkstra' next found visited' previous' costs'' current'

-- | @dijkstra next found initial@ performs a shortest-path search over
-- a set of states using Dijkstra's algorithm, starting with @initial@,
-- generating neighboring states with associated incremenal costs with
-- @next@. This will find the least-costly path from an initial state to a
-- state for which @found@ returns 'True'. Returns 'Nothing' if no path to a
-- solved state is possible.
dijkstra ::
    (Ord state, Ord cost, Num cost)
    => (state -> [(state, cost)])
    -- ^ Function to generate list of neighboring states with associated costs
    -> (state -> Bool)
    -- ^ Predicate to determine if solution found. 'dijkstra' returns the
    -- shortest path to the first state for which this predicate returns 'True'.
    -> state
    -- ^ Initial state
    -> Maybe (cost, [state])
    -- ^ (Total cost, list of steps) for the first path found which satisfies
    -- the given predicate
dijkstra next found initial =
    dijkstra' next found S.empty M.empty (singleton initial) initial

